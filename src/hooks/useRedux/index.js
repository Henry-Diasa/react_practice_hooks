import React from "react";

export const ReduxContext = React.createContext(null);

export function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (
    typeof objA !== "object" ||
    objA === null ||
    typeof objB !== "object" ||
    objB === null
  ) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (
      !hasOwnProperty.call(objB, keysA[i]) ||
      !Object.is(objA[keysA[i]], objB[keysA[i]])
    ) {
      return false;
    }
  }
  return true;
}

import { unstable_batchedUpdates } from "react-dom";

class ReduxHooksStore {
  constructor(reducer, initState) {
    this.name = "__ReduxHooksStore__";
    this.id = 0;
    this.reducer = reducer;
    this.state = initState;
    this.mapConnects = {};
  }
  /* 需要对外传递的接口 */
  exportStore = () => {
    return {
      dispatch: this.dispatch.bind(this),
      subscribe: this.subscribe.bind(this),
      unSubscribe: this.unSubscribe.bind(this),
      getInitState: this.getInitState.bind(this)
    };
  };
  /* 获取初始化 state */
  getInitState = (mapStoreToState) => {
    return mapStoreToState(this.state);
  };
  /* 更新需要更新的组件 */
  publicRender = () => {
    unstable_batchedUpdates(() => {
      /* 批量更新 */
      Object.keys(this.mapConnects).forEach((name) => {
        const { update } = this.mapConnects[name];
        update(this.state);
      });
    });
  };
  /* 更新 state  */
  dispatch = (action) => {
    this.state = this.reducer(this.state, action);
    this.publicRender();
  };
  /* 注册每个 connect  */
  subscribe = (connectCurrent) => {
    const connectName = this.name + ++this.id;
    this.mapConnects[connectName] = connectCurrent;
    console.log(this.mapConnects, "this.mapConnects");
    return connectName;
  };
  /* 解除绑定 */
  unSubscribe = (connectName) => {
    delete this.mapConnects[connectName];
  };
}

/* 用于产生 reduxHooks 的 store */
export function useCreateStore(reducer, initState) {
  const store = React.useRef(null);
  /* 如果存在——不需要重新实例化 Store */
  if (!store.current) {
    store.current = new ReduxHooksStore(reducer, initState).exportStore();
  }
  return store.current;
}

export function useConnect(mapStoreToState = () => {}) {
  /* 获取 Store 内部的重要函数 */
  const contextValue = React.useContext(ReduxContext);
  const { getInitState, subscribe, unSubscribe, dispatch } = contextValue;
  /* 更新  */
  const stateValue = React.useRef(getInitState(mapStoreToState));
  /* 渲染函数 */
  const [, forceUpdate] = React.useState();
  /* 产生 */
  const connectValue = React.useMemo(() => {
    const state = {
      cacheState: stateValue.current,
      /* 更新函数 */
      update: function (newState) {
        /*  */
        const selectState = mapStoreToState(newState);
        /* 浅比较 state 是否发生变化，如果发生变化， */
        const isEqual = shallowEqual(state.cacheState, selectState);
        state.cacheState = selectState;
        stateValue.current = selectState;
        if (!isEqual) {
          /* 更新 */
          forceUpdate({});
        }
      }
    };
    return state;
  }, [contextValue]); // 将 contextValue 作为依赖项。

  React.useEffect(() => {
    /* 组件挂载——注册 connect */
    const name = subscribe(connectValue);
    return function () {
      /* 组件卸载 —— 解绑 connect */
      unSubscribe(name);
    };
  }, [connectValue]); /* 将 connectValue 作为 useEffect 的依赖项 */

  return [stateValue.current, dispatch];
}
